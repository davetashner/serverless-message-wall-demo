apiVersion: v1
kind: ConfigMap
metadata:
  name: argocd-cmp-confighub
  namespace: argocd
data:
  plugin.yaml: |
    apiVersion: argoproj.io/v1alpha1
    kind: ConfigManagementPlugin
    metadata:
      name: confighub
    spec:
      # Note: Omitting 'version' so socket is named 'confighub.sock' not 'confighub-v1.0.sock'

      # Discovery: identify when this plugin should be used
      # Always return true since this plugin is explicitly requested via source.plugin.name
      # The actual ConfigHub space is specified via source.plugin.env.CONFIGHUB_SPACE
      discover:
        find:
          command: ["/bin/sh", "-c"]
          args:
            - |
              # Always match - this plugin is explicitly requested in Application spec
              # The git repo is just a placeholder; actual content comes from ConfigHub
              echo "confighub"

      # Init: authenticate with ConfigHub as a worker
      init:
        command: ["/bin/sh", "-c"]
        args:
          - |
            echo "Initializing ConfigHub CMP..."
            if [ -z "$CONFIGHUB_WORKER_ID" ] || [ -z "$CONFIGHUB_WORKER_SECRET" ]; then
              echo "Warning: ConfigHub credentials not configured"
              echo "Run scripts/setup-argocd-confighub-auth.sh to configure"
              exit 0
            fi
            cub auth login --as-worker

      # Generate: fetch all units from ConfigHub space at their LiveRevisionNum
      # This ensures ArgoCD only syncs configuration that has been explicitly
      # promoted via 'cub unit apply', not just any revision pushed to ConfigHub.
      # See ISSUE-8.6 for the controlled rollout design.
      generate:
        command: ["/bin/sh", "-c"]
        args:
          - |
            if [ -z "$CONFIGHUB_SPACE" ]; then
              echo "Error: CONFIGHUB_SPACE not set" >&2
              exit 1
            fi

            if [ -z "$CONFIGHUB_WORKER_ID" ]; then
              echo "# ConfigHub credentials not configured"
              echo "# Run scripts/setup-argocd-confighub-auth.sh to configure"
              exit 0
            fi

            # Fetch each unit's content at its LiveRevisionNum (not HeadRevisionNum)
            # This ensures only promoted revisions are synced to Kubernetes.
            # Units with LiveRevisionNum=0 have never been applied and are skipped.
            cub unit list --space "$CONFIGHUB_SPACE" --no-header \
              --columns Unit.Slug,Unit.LiveRevisionNum 2>/dev/null | while read -r unit live_rev; do
              if [ -n "$unit" ] && [ -n "$live_rev" ] && [ "$live_rev" != "0" ]; then
                cub revision get --space "$CONFIGHUB_SPACE" --data-only "$unit" "$live_rev" 2>/dev/null
                echo "---"
              fi
            done
